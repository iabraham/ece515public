<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=D51V29r3BtOBcI-sslA47MI7uxzF29VHzUqoRXLrPtwLBJrCeLhaqZ1U8RkFGsAn);ol{margin:0;padding:0}table td,table th{padding:0}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c13{text-decoration-skip-ink:none;font-family:"Google Sans Text";-webkit-text-decoration-skip:none;color:#0000ff;font-weight:700;text-decoration:underline}.c1{background-color:#f0f4f9;font-size:10pt;font-family:"Google Sans Text";font-style:normal;color:#188038;font-weight:400}.c18{margin-left:12pt;padding-top:6pt;padding-bottom:7.5pt;line-height:1.149999976158142;text-align:left;margin-right:6pt}.c2{background-color:#f0f4f9;font-size:10pt;font-family:"Google Sans Text";font-style:normal;color:#1967d2;font-weight:400}.c27{text-decoration-skip-ink:none;font-family:"Google Sans Text";-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.149999976158142;text-align:left;height:11pt}.c0{background-color:#f0f4f9;font-family:"Google Sans Text";color:#1b1c1d;font-weight:400}.c14{padding-top:0pt;padding-bottom:12pt;line-height:1.149999976158142;text-align:left}.c8{background-color:#f0f4f9;font-family:"Google Sans Text";color:#d93025;font-weight:400}.c10{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c4{background-color:#f0f4f9;font-family:"Google Sans Text";color:#b55908;font-weight:400}.c5{background-color:#f0f4f9;font-family:"Google Sans Text";color:#5f6368;font-weight:400}.c25{padding-top:0pt;padding-bottom:12pt;line-height:1.149999976158142;text-align:center}.c24{padding-top:0pt;padding-bottom:0pt;line-height:1.149999976158142;text-align:left}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c19{background-color:#f0f4f9;color:#575b5f;font-weight:400;font-family:"Google Sans Text"}.c6{background-color:#f0f4f9;font-family:"Google Sans Text";color:#8430ce;font-weight:400}.c26{vertical-align:baseline;font-size:11pt;font-style:normal}.c20{color:#0000ff;font-weight:400;font-family:"Google Sans Text"}.c17{background-color:#ffffff;max-width:648pt;padding:72pt 72pt 72pt 72pt}.c7{color:#1b1c1d;font-weight:400;font-family:"Google Sans Text"}.c23{color:#0000ff;font-weight:700;font-family:"Google Sans Text"}.c3{font-size:10pt;font-style:normal}.c16{color:inherit;text-decoration:inherit}.c15{border:1px solid black;margin:5px}.c22{margin-left:12pt;margin-right:6pt}.c21{height:11pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.0;page-break-after:avoid;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:12pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:12pt;font-family:"Arial";line-height:1.0;text-align:left}h2{padding-top:11.2pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:11.2pt;font-family:"Arial";line-height:1.0;text-align:left}h3{padding-top:12pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:12pt;font-family:"Arial";line-height:1.0;text-align:left}h4{padding-top:12.8pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:12.8pt;font-family:"Arial";line-height:1.0;text-align:left}h5{padding-top:12.8pt;color:#000000;font-weight:700;font-size:9pt;padding-bottom:12.8pt;font-family:"Arial";line-height:1.0;text-align:left}h6{padding-top:18pt;color:#000000;font-weight:700;font-size:8pt;padding-bottom:18pt;font-family:"Arial";line-height:1.0;text-align:left}</style></head><body class="c17 doc-content"><p class="c14"><span class="c13">Document author</span><span class="c23">: &nbsp;</span><span class="c27"><a class="c16" href="https://www.google.com/url?q=https://www.ivan.web.illinois.edu/&amp;sa=D&amp;source=editors&amp;ust=1753197891030279&amp;usg=AOvVaw3Bq3T3eZATdRrdQ4JllnCq">itabrah2@illinois.edu</a></span></p><p class="c14"><span class="c13">Prompt:</span><span class="c10 c20">&nbsp;I want to create a simple interactive notebook to show students the relation between Q, R and N matrices and pendulum dynamics where the objective is to stabilize an inverted pendulum using LQR control. I want to do this in Julia using Pluto notebooks and the Pluto UI sliders. Please help. The notebook should have three sections -- (a) derivations of EOM using the Symbolics.jl package followed by linearization, (b) implementation of LQR control and (c) interactive part to vary LQR gains and see change in system response.</span></p><p class="c14"><span class="c13">System:</span><span class="c10 c20">&nbsp;Google Gemini 2.5 Pro</span></p><p class="c14 c21"><span class="c10 c20"></span></p><p class="c25"><span class="c13 c26">Response</span></p><p class="c14"><span class="c10 c7">Of course. Here is the complete code for a Pluto notebook that interactively demonstrates LQR control for an inverted pendulum.</span></p><p class="c14"><span class="c7">You can copy and paste the entire code block below into a single cell in a new Julia Pluto notebook. </span><span class="c7">Pluto&#39;s reactive nature will automatically separate it into multiple cells and create the interactive demonstration.</span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup></p><p class="c14 c21 c22"><span class="c10 c7"></span></p><p class="c18"><span class="c10 c19">Julia</span></p><p class="c12"><span class="c10 c19"></span></p><p class="c12"><span class="c10 c19"></span></p><p class="c24"><span class="c5 c3">### A Pluto.jl notebook for a lecture on inverted pendulum dynamics and LQR control</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># Sections:</span><span class="c0"><br></span><span class="c5 c3"># (a) Derivations of EOM using the Symbolics.jl package followed by linearization</span><span class="c0"><br></span><span class="c5 c3"># (b) Implementation of LQR control</span><span class="c0"><br></span><span class="c5 c3"># (c) Interactive part to vary LQR gains and see change in system response</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># This notebook was generated by Gemini.</span><span class="c0"><br></span><span class="c5 c3">###</span><span class="c0"><br><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># ## &#128230; Package Installation and Loading</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># The first step is to load all the required packages. If they are not installed,</span><span class="c0"><br></span><span class="c5 c3"># Julia&#39;s package manager will handle the installation automatically.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Import required packages</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">using</span><span class="c0">&nbsp;PlutoUI<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">using</span><span class="c0">&nbsp;Symbolics<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">using</span><span class="c0">&nbsp;ControlSystems<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">using</span><span class="c0">&nbsp;DifferentialEquations<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">using</span><span class="c0">&nbsp;LinearAlgebra<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">using</span><span class="c0">&nbsp;Plots<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Set plotting backend</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gr()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Set a nice theme for plots</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theme(:dark)<br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># # (a) &#128220; Derivation of Equations of Motion</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># In this section, we derive the system&#39;s equations of motion (EOM) using Lagrangian mechanics. The [`Symbolics.jl`](https://symbolics.juliasymbols.org/stable/) package allows us to perform these derivations automatically.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># The system consists of a cart of mass $M$ and a pendulum of mass $m$ with length $L$. The states are the cart&#39;s position $x$ and the pendulum&#39;s angle $\theta$ (where $\theta=0$ is the upright position). A force $u$ is applied to the cart.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### Symbolic Variables<br><br>First, we define all symbolic variables for our system parameters, states, and their time derivatives.<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">@variables</span><span class="c0">&nbsp;t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5 c3"># time</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">@variables</span><span class="c0">&nbsp;m M L g &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5 c3"># system parameters</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">@variables</span><span class="c0">&nbsp;x(t) &theta;(t) u(t) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c5 c3"># states and input</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define differential operator</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D = Differential(t)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Display variables nicely in LaTeX</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t, m, M, L, g, x, &theta;, u, D)<br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### Lagrangian Mechanics<br><br>We use the principle of Lagrangian mechanics to find the EOM. The Lagrangian $\mathcal{L}$ is defined as the difference between the system&#39;s kinetic energy (</span><span class="c8 c3">$T</span><span class="c1">$) and potential energy (</span><span class="c8 c3">$V</span><span class="c1">$).<br><br>$\mathcal{L} = T - V$<br><br>1. &nbsp;**Kinetic Energy (</span><span class="c8 c3">$T</span><span class="c1">$)**: This is the sum of the kinetic energy of the cart and the pendulum bob.<br> &nbsp; &nbsp;* </span><span class="c8 c3">$T_</span><span class="c1">{cart} = \frac{1}{2} M (\dot{x})^2$<br> &nbsp; &nbsp;* </span><span class="c8 c3">$T_</span><span class="c1">{pendulum} = \frac{1}{2} m (v_{px}^2 + v_{py}^2)$<br> &nbsp;</span><span class="c1">&nbsp; where </span><span class="c8 c3">$x_p</span><span class="c1">&nbsp;= x + L \sin(\theta)$ and </span><span class="c8 c3">$y_p</span><span class="c1">&nbsp;= L \cos(\theta)$.</span><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><span class="c1"><br><br>2. &nbsp;**Potential Energy (</span><span class="c8 c3">$V</span><span class="c1">$)**: This is determined by the height of the pendulum bob.<br> &nbsp; &nbsp;* </span><span class="c8 c3">$V</span><span class="c1">&nbsp;= m g L \cos(\theta)$<br><br>The equations of motion are then found using the Euler-Lagrange equation for each generalized coordinate (</span><span class="c8 c3">$q_i</span><span class="c1">&nbsp;\in \{x, \theta\}$), including the external force </span><span class="c8 c3">$u</span><span class="c1">$ applied to </span><span class="c8 c3">$x</span><span class="c1">$:<br><br>$\frac{d}{dt} \frac{\partial \mathcal{L}}{\partial \dot{q_i}} - \frac{\partial \mathcal{L}}{\partial q_i} = F_{q_i}$<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Position of pendulum bob</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_p = x + L * sin(&theta;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_p = L * cos(&theta;)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Velocity of pendulum bob</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_px = D(x_p)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_py = D(y_p)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># 1. Kinetic Energy (T)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T_cart = </span><span class="c4 c3">0.5</span><span class="c0">&nbsp;* M * D(x)^</span><span class="c4 c3">2</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T_pend = </span><span class="c4 c3">0.5</span><span class="c0">&nbsp;* m * (v_px^</span><span class="c4 c3">2</span><span class="c0">&nbsp;+ v_py^</span><span class="c4 c3">2</span><span class="c0">)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T = T_cart + T_pend<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># 2. Potential Energy (V)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V = m * g * L * cos(&theta;)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># 3. Lagrangian (L)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lag = T - V<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># 4. Euler-Lagrange Equations</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Generalized coordinates q = [x, &theta;]</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Forces F = [u, 0]</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL_x = D(gradient(Lag, [D(x)])[</span><span class="c4 c3">1</span><span class="c0">]) - gradient(Lag, [x])[</span><span class="c4 c3">1</span><span class="c0">] ~ u<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL_&theta; = D(gradient(Lag, [D(&theta;)])[</span><span class="c4 c3">1</span><span class="c0">]) - gradient(Lag, [&theta;])[</span><span class="c4 c3">1</span><span class="c0">] ~ </span><span class="c4 c3">0</span><span class="c0"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Display the two EOMs</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(EL_x, EL_&theta;)<br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### Solving for Accelerations<br><br>The equations above are implicit. To get our standard state-space form, we need to solve for the accelerations $\ddot{x}$ and $\ddot{\theta}$.<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Solve for the second derivatives (accelerations)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol = Symbolics.</span><span class="c0">solve_for</span><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup><span class="c0">([</span><span class="c0">EL_x, EL_&theta;</span><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup><span class="c0">], [D(D(x)), D(D(&theta;))])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_dd_expr = sol[</span><span class="c4 c3">1</span><span class="c0">]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&theta;_dd_expr = sol[</span><span class="c4 c3">2</span><span class="c0">]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1">md&quot;&quot;&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solved expression for cart acceleration $\ddot{x}$ is:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ \ddot{x} = </span><span class="c0 c3">$(latexify(x_dd_expr)</span><span class="c1">) $$<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solved expression for pendulum angular acceleration $\ddot{\theta}$ is:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ \ddot{\theta} = </span><span class="c0 c3">$(latexify(&theta;_dd_expr)</span><span class="c1">) $$<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="c0"><br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### System Linearization<br><br>The LQR controller requires a linear time-invariant (LTI) model of the form $\dot{\mathbf{z}} = A\mathbf{z} + B\mathbf{u}$. We linearize our nonlinear system around the unstable equilibrium point: pendulum perfectly upright and stationary at the origin.<br><br>The state vector is $\mathbf{z} = [x, \dot{x}, \theta, \dot{\theta}]^T$.<br>The equilibrium point is $\mathbf{z}_{eq} = [0, 0, 0, 0]^T$ and </span><span class="c8 c3">$u_</span><span class="c1">{eq} = 0$.<br><br>The matrices </span><span class="c8 c3">$A</span><span class="c1">$ and </span><span class="c8 c3">$B</span><span class="c1">$ are the Jacobians of the system dynamics with respect to the state and input, evaluated at the equilibrium point.<br><br></span><span class="c8 c3">$A</span><span class="c1">&nbsp;= \frac{\partial f}{\partial \mathbf{z}} \bigg|_{\mathbf{z}_{eq}, u_{eq}}$ and </span><span class="c8 c3">$B</span><span class="c1">&nbsp;= \frac{\partial f}{\partial u} \bigg|_{\mathbf{z}_{eq}, u_{eq}}$<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define the symbolic state vector and nonlinear dynamics function f</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z = [x, D(x), &theta;, D(&theta;)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_sym = [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D(x),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_dd_expr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D(&theta;),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&theta;_dd_expr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Compute the Jacobians symbolically</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A_sym = Symbolics.jacobian(f_sym, z)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_sym = Symbolics.jacobian(f_sym, [u])<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define the equilibrium point</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq_point = </span><span class="c2">Dict</span><span class="c0">(x =&gt; </span><span class="c4 c3">0</span><span class="c0">, D(x) =&gt; </span><span class="c3 c4">0</span><span class="c0">, &theta; =&gt; </span><span class="c4 c3">0</span><span class="c0">, D(&theta;) =&gt; </span><span class="c4 c3">0</span><span class="c0">, u =&gt; </span><span class="c4 c3">0</span><span class="c0">)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Substitute the equilibrium point values into the Jacobians</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A_eq = substitute(A_sym, eq_point)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_eq = substitute(B_sym, eq_point)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1">md&quot;&quot;&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbolic linearized state matrix </span><span class="c8 c3">$A</span><span class="c1">$ is:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ A = </span><span class="c0 c3">$(latexify(A_eq)</span><span class="c1">) $$<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The symbolic linearized input matrix </span><span class="c8 c3">$B</span><span class="c1">$ is:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ B = </span><span class="c0 c3">$(latexify(B_eq)</span><span class="c1">) $$<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="c0"><br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c3 c5"># # (b) &#129302; LQR Controller Implementation</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># The Linear-Quadratic Regulator (LQR) is an optimal control strategy. It finds the feedback control law $u = -K\mathbf{z}$ that minimizes a quadratic cost function:</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># $J = \int_{0}^{\infty} (\mathbf{z}^T Q \mathbf{z} + u^T R u) \,dt$</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># * **Q matrix**: A positive semi-definite matrix that penalizes deviations in the state variables from the equilibrium.</span><span class="c0"><br></span><span class="c5 c3"># * **R matrix**: A positive definite matrix that penalizes control effort.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># The trade-off is key: large values in $Q$ lead to aggressive control, while large values in $R$ lead to conservative, energy-saving control.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### Numerical System Model<br><br>Let&#39;s define numerical values for our system parameters and compute the numerical </span><span class="c8 c3">$A</span><span class="c1">$ and </span><span class="c8 c3">$B</span><span class="c1">$ matrices.<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define a dictionary with numerical parameters</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># We use `Float64` to ensure the resulting matrices are not symbolic</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;params = </span><span class="c2">Dict</span><span class="c0">(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M =&gt; </span><span class="c4 c3">1.0</span><span class="c0">, &nbsp; &nbsp; &nbsp;</span><span class="c5 c3"># Cart mass (kg)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m =&gt; </span><span class="c4 c3">0.2</span><span class="c0">, &nbsp; &nbsp; &nbsp;</span><span class="c5 c3"># Pendulum mass (kg)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L =&gt; </span><span class="c4 c3">0.5</span><span class="c0">, &nbsp; &nbsp; &nbsp;</span><span class="c5 c3"># Pendulum length (m)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g =&gt; </span><span class="c4 c3">9.81</span><span class="c0">&nbsp; &nbsp; &nbsp; </span><span class="c5 c3"># Gravitational acceleration (m/s&sup2;)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Substitute numerical values into the symbolic A and B matrices</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A_num = </span><span class="c2">Float64</span><span class="c0">.(substitute(</span><span class="c0">A_eq</span><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup><span class="c0">, params))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_num = </span><span class="c2">Float64</span><span class="c0">.(substitute(</span><span class="c0">B_eq</span><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><span class="c0">, params))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Create the state-space model using ControlSystems.jl</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys_linear = ss(A_num, B_num, I(</span><span class="c4 c3">4</span><span class="c0">), </span><span class="c4 c3">0</span><span class="c0">)<br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>Using the parameters </span><span class="c8 c3">$M</span><span class="c1">&nbsp;= </span><span class="c0 c3">$(params[M])</span><span class="c1">\,</span><span class="c8 c3">$kg</span><span class="c1">, </span><span class="c8 c3">$m</span><span class="c1">&nbsp;= </span><span class="c0 c3">$(params[m])</span><span class="c1">\,</span><span class="c8 c3">$kg</span><span class="c1">, </span><span class="c8 c3">$L</span><span class="c1">&nbsp;= </span><span class="c0 c3">$(params[L])</span><span class="c1">\,</span><span class="c3 c8">$m</span><span class="c1">, and </span><span class="c8 c3">$g</span><span class="c1">&nbsp;= </span><span class="c0 c3">$(params[g])</span><span class="c1">\,</span><span class="c8 c3">$m</span><span class="c1">/s&sup2;, our linearized system matrices are:<br><br></span><span class="c8 c3">$A</span><span class="c1">&nbsp;= </span><span class="c0 c3">$(sprint(show, </span><span class="c1">&quot;text/plain&quot;</span><span class="c0 c3">, A_num)</span><span class="c1">)$<br><br></span><span class="c8 c3">$B</span><span class="c1">&nbsp;= </span><span class="c0 c3">$(sprint(show, </span><span class="c1">&quot;text/plain&quot;</span><span class="c0 c3">, B_num)</span><span class="c1">)$<br><br>The system is unstable, which we can confirm by checking the eigenvalues of the </span><span class="c8 c3">$A</span><span class="c1">$ matrix. A positive eigenvalue indicates instability.<br><br>Eigenvalues of A: **</span><span class="c0 c3">$(round.(eigvals(A_num)</span><span class="c1">, digits=2))**<br>&quot;&quot;&quot;</span><span class="c0"><br><br><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># # (c) &#128377;&#65039; Interactive LQR Simulation</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># Now for the fun part! Use the sliders below to adjust the LQR cost matrices $Q$ and $R$. Observe how the system&#39;s response changes.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># * **Position Cost ($Q_{11}$)**: How much to penalize the cart for not being at the origin ($x=0$).</span><span class="c0"><br></span><span class="c5 c3"># * **Angle Cost ($Q_{33}$)**: How much to penalize the pendulum for not being upright ($\theta=0$).</span><span class="c0"><br></span><span class="c5 c3"># * **Control Cost ($R_{11}$)**: How much to penalize using the motor force ($u$).</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># We will simulate the response of both the **linearized model** and the **original nonlinear model** to the same LQR controller to see how they compare.</span><span class="c0"><br></span><span class="c5 c3">#</span><span class="c0"><br></span><span class="c5 c3"># ------------------------------------------------------------------------------------------</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### LQR Cost Sliders<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c2">@bind</span><span class="c0">&nbsp;q1_slider Slider(</span><span class="c4 c3">0.1</span><span class="c0">:</span><span class="c4 c3">0.1</span><span class="c0">:</span><span class="c4 c3">20</span><span class="c0">, default=</span><span class="c4 c3">1.0</span><span class="c0">, show_value=</span><span class="c4 c3">true</span><span class="c0">)<br></span><span class="c2">@bind</span><span class="c0">&nbsp;q3_slider Slider(</span><span class="c4 c3">0.1</span><span class="c0">:</span><span class="c4 c3">0.1</span><span class="c0">:</span><span class="c4 c3">20</span><span class="c0">, default=</span><span class="c4 c3">10.0</span><span class="c0">, show_value=</span><span class="c4 c3">true</span><span class="c0">)<br></span><span class="c2">@bind</span><span class="c0">&nbsp;r_slider Slider(</span><span class="c4 c3">0.01</span><span class="c0">:</span><span class="c4 c3">0.01</span><span class="c0">:</span><span class="c4 c3">2.0</span><span class="c0">, default=</span><span class="c4 c3">0.1</span><span class="c0">, show_value=</span><span class="c4 c3">true</span><span class="c0">)<br><br></span><span class="c1">md&quot;&quot;&quot;<br>**Position Cost (</span><span class="c8 c3">$Q_</span><span class="c1">{11}$)**: </span><span class="c0 c3">$( PlutoUI.Show(q1_slider)</span><span class="c1">&nbsp;)<br>**Angle Cost (</span><span class="c8 c3">$Q_</span><span class="c1">{33}$)**: </span><span class="c0 c3">$( PlutoUI.Show(q3_slider)</span><span class="c1">&nbsp;)<br>**Control Cost (</span><span class="c8 c3">$R</span><span class="c1">$)**: </span><span class="c0 c3">$( PlutoUI.Show(r_slider)</span><span class="c1">&nbsp;)<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c3 c6">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define Q and R matrices based on slider values</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># We penalize position (z1) and angle (z3). Velocity penalties (z2, z4) are often less critical for stabilization.</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q = diagm([q1_slider, </span><span class="c4 c3">0</span><span class="c0">, q3_slider, </span><span class="c4 c3">0</span><span class="c0">])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R = [r_slider]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Compute the LQR gain K for the linear system</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># The lqr function solves the algebraic Riccati equation to find K</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K, _, _ = lqr(sys_linear, Q, R)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Display the calculated gain matrix</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1">md&quot;&quot;&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The resulting LQR gain matrix </span><span class="c8 c3">$K</span><span class="c1">$ is: **</span><span class="c0 c3">$(round.(K, digits=</span><span class="c4 c3">2</span><span class="c0 c3">)</span><span class="c1">)**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;</span><span class="c0"><br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### System Simulation<br><br>We now simulate the closed-loop system dynamics for an initial condition where the pendulum is slightly tilted.<br><br>* Initial state: $\mathbf{z}_0 = [x=0, \dot{x}=0, \theta=0.1, \dot{\theta}=0]^T$.<br>* Control law: </span><span class="c8 c3">$u</span><span class="c1">&nbsp;= -K \mathbf{z}$<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># ---- 1. Simulation Setup ----</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&#8320; = </span><span class="c4 c3">0.0</span><span class="c0">&nbsp; &nbsp; </span><span class="c5 c3"># initial cart position</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&theta;&#8320; = </span><span class="c4 c3">0.1</span><span class="c0">&nbsp; &nbsp; </span><span class="c5 c3"># initial pendulum angle (in radians, approx 5.7 degrees)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&#8320; = [x&#8320;, </span><span class="c4 c3">0.0</span><span class="c0">, &theta;&#8320;, </span><span class="c4 c3">0.0</span><span class="c0">] &nbsp;</span><span class="c5 c3"># Initial state vector</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t_span = (</span><span class="c4 c3">0.0</span><span class="c0">, </span><span class="c4 c3">10.0</span><span class="c0">) &nbsp; &nbsp;</span><span class="c5 c3"># Simulation time span</span><span class="c0"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># ---- 2. Nonlinear System Dynamics ----</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Here we build the function for the ODE solver using the symbolic expressions</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># This avoids manual transcription errors and is highly reusable.</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># The `build_function` call generates highly optimized code.</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_nonlinear_oop = build_function(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_sym, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[z...], [u], [M, m, L, g], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expression=</span><span class="c2">Val</span><span class="c0">{</span><span class="c4 c3">false</span><span class="c0">}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)[</span><span class="c4 c3">1</span><span class="c0">]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define the closed-loop function for the nonlinear system</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">function</span><span class="c0">&nbsp;nonlinear_dynamics!(dz, z, p, t)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Unpack parameters and gain matrix</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_val, m_val, L_val, g_val, K_mat = p<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Calculate control input</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_val = -K_mat * z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Call the generated function</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Note: The generated function expects a scalar u, so we extract it.</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dz .= f_nonlinear_oop(z, u_val[</span><span class="c4 c3">1</span><span class="c0">], [M_val, m_val, L_val, g_val], t)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">end</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># ---- 3. Linear System Dynamics ----</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Define the closed-loop function for the linearized system</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">function</span><span class="c0">&nbsp;linear_dynamics!(dz, z, p, t)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A_mat, B_mat, K_mat = p<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dz .= (A_mat - B_mat * K_mat) * z<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c6 c3">end</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># ---- 4. Solve the ODEs ----</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Solve nonlinear system</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_nonlin = (params[M], params[m], params[L], params[g], K)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prob_nonlin = ODEProblem(nonlinear_dynamics!, z&#8320;, t_span, p_nonlin)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol_nonlin = solve(prob_nonlin, Tsit5(), saveat=</span><span class="c4 c3">0.05</span><span class="c0">)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Solve linear system</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_lin = (A_num, B_num, K)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prob_lin = ODEProblem(linear_dynamics!, z&#8320;, t_span, p_lin)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol_lin = solve(prob_lin, Tsit5(), saveat=</span><span class="c4 c3">0.05</span><span class="c0">)<br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### &#128202; Simulation Results<br><br>The plots below show the cart position, pendulum angle, and control force over time. The solid line represents the **nonlinear model**, while the dashed line represents the **linear model**.<br>&quot;&quot;&quot;</span><span class="c0"><br><br></span><span class="c6 c3">begin</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Plot 1: Cart Position (x)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">p1 = plot(<br></span><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol_lin.t, [s[</span><span class="c4 c3">1</span><span class="c0">] </span><span class="c6 c3">for</span><span class="c0">&nbsp;s </span><span class="c6 c3">in</span><span class="c0">&nbsp;sol_lin.u], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label=</span><span class="c1">&quot;Linear&quot;</span><span class="c0">, linestyle=:dash, lw=</span><span class="c4 c3">2</span><span class="c0">,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title=</span><span class="c1">&quot;Cart Position&quot;</span><span class="c0">, xlabel=</span><span class="c1">&quot;Time (s)&quot;</span><span class="c0">, ylabel=</span><span class="c1">&quot;Position (m)&quot;</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot!(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1, sol_nonlin.t, [s[</span><span class="c4 c3">1</span><span class="c0">] </span><span class="c6 c3">for</span><span class="c0">&nbsp;s </span><span class="c6 c3">in</span><span class="c0">&nbsp;sol_nonlin.u],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label=</span><span class="c1">&quot;Nonlinear&quot;</span><span class="c0">, lw=</span><span class="c4 c3">2</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Plot 2: Pendulum Angle (&theta;)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2 = plot(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol_lin.t, [rad2deg(s[</span><span class="c4 c3">3</span><span class="c0">]) </span><span class="c6 c3">for</span><span class="c0">&nbsp;s </span><span class="c6 c3">in</span><span class="c0">&nbsp;sol_lin.u], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label=</span><span class="c1">&quot;Linear&quot;</span><span class="c0">, linestyle=:dash, lw=</span><span class="c4 c3">2</span><span class="c0">,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title=</span><span class="c1">&quot;Pendulum Angle&quot;</span><span class="c0">, xlabel=</span><span class="c1">&quot;Time (s)&quot;</span><span class="c0">, ylabel=</span><span class="c1">&quot;Angle (&deg;)&quot;</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot!(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p2, sol_nonlin.t, [rad2deg(s[</span><span class="c4 c3">3</span><span class="c0">]) </span><span class="c6 c3">for</span><span class="c0">&nbsp;s </span><span class="c6 c3">in</span><span class="c0">&nbsp;sol_nonlin.u], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label=</span><span class="c1">&quot;Nonlinear&quot;</span><span class="c0">, lw=</span><span class="c4 c3">2</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Plot 3: Control Input (u)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># u(t) = -K * z(t)</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_lin = [-K * s </span><span class="c6 c3">for</span><span class="c0">&nbsp;s </span><span class="c6 c3">in</span><span class="c0">&nbsp;sol_lin.u]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_nonlin = [-K * s </span><span class="c6 c3">for</span><span class="c0">&nbsp;s </span><span class="c6 c3">in</span><span class="c0">&nbsp;sol_nonlin.u]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p3 = plot(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol_lin.t, u_lin, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label=</span><span class="c1">&quot;Linear&quot;</span><span class="c0">, linestyle=:dash, lw=</span><span class="c4 c3">2</span><span class="c0">,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title=</span><span class="c1">&quot;Control Input&quot;</span><span class="c0">, xlabel=</span><span class="c1">&quot;Time (s)&quot;</span><span class="c0">, ylabel=</span><span class="c1">&quot;Force (N)&quot;</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot!(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p3, sol_nonlin.t, u_nonlin,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label=</span><span class="c1">&quot;Nonlinear&quot;</span><span class="c0">, lw=</span><span class="c4 c3">2</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5 c3"># Combine plots into one layout</span><span class="c0"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot(p1, p2, p3, layout=(</span><span class="c4 c3">3</span><span class="c0">,</span><span class="c4 c3">1</span><span class="c0">), size=(</span><span class="c4 c3">800</span><span class="c0">, </span><span class="c4 c3">700</span><span class="c0">), legend=:topright)<br></span><span class="c6 c3">end</span><span class="c0"><br><br></span><span class="c1">md&quot;&quot;&quot;<br>### &#129300; Interpretation<br><br>* **High Angle Cost (</span><span class="c8 c3">$Q_</span><span class="c1">{33}$)**: If you increase the penalty on the angle, the controller will act more aggressively to bring $\theta$ to zero, often resulting in larger control inputs and more overshoot in the cart&#39;s position.<br>* **High Position Cost (</span><span class="c8 c3">$Q_</span><span class="c1">{11}$)**: Increasing the penalty on position forces the cart to return to the origin more quickly.<br>* **High Control Cost (</span><span class="c8 c3">$R</span><span class="c1">$)**: If you increase the penalty on the control force, the controller becomes &quot;lazier&quot; to save energy. This results in a slower response and smaller control signals. If </span><span class="c8 c3">$R</span><span class="c1">$ is too high, the controller may not be strong enough to stabilize the pendulum at all.<br>* **Linear vs. Nonlinear**: For small initial angles, the linear and nonlinear responses are very similar. If you were to increase the initial angle `&theta;&#8320;` in the code, you would see the linear model become a less accurate predictor of the true nonlinear behavior.<br>&quot;&quot;&quot;</span><span class="c0 c10"><br></span></p><div class="c15"><p class="c11"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c9">Not really. That won&#39;t work but given output is a good starting place.</span></p></div><div class="c15"><p class="c11"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c9">Gemini didn&#39;t define what x_p and y_p are over here.</span></p></div><div class="c15"><p class="c11"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c9">Deprecated, replace with `Symbolics.symbolic_linear_solve`</span></p></div><div class="c15"><p class="c11"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c9">These have unexpanded derivatives in them. Replace with `eqns` where</span></p><p class="c11 c21"><span class="c9"></span></p><p class="c11"><span class="c9">```</span></p><p class="c11"><span class="c9">eqns = expand_derivatives.([EL_x, EL_&theta;])</span></p><p class="c11"><span class="c9">```</span></p></div><div class="c15"><p class="c11"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c9">A_eq and B_eq are no longer symbolics here because of previous call to substitute.&nbsp;</span></p><p class="c11 c21"><span class="c9"></span></p><p class="c11"><span class="c9">Replace with&nbsp;</span></p><p class="c11"><span class="c9">```</span></p><p class="c11"><span class="c9">A_num = Float64.(substitute(A_sym, merge(params, eq_point)))</span></p><p class="c11"><span class="c9">B_num = Float64.(substitute(B_sym, merge(params, eq_point)))</span></p><p class="c11 c21"><span class="c9"></span></p><p class="c11"><span class="c9">```</span></p></div><div class="c15"><p class="c11"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c9">A_eq and B_eq are no longer symbolics here because of previous call to substitute.&nbsp;</span></p><p class="c11 c21"><span class="c9"></span></p><p class="c11"><span class="c9">Replace with&nbsp;</span></p><p class="c11"><span class="c9">```</span></p><p class="c11"><span class="c9">A_num = Float64.(substitute(A_sym, merge(params, eq_point)))</span></p><p class="c11"><span class="c9">B_num = Float64.(substitute(B_sym, merge(params, eq_point)))</span></p><p class="c11 c21"><span class="c9"></span></p><p class="c11"><span class="c9">```</span></p></div><div class="c15"><p class="c11"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c9">Might be a good idea to fix the ylims in all these plots to see changes better.</span></p></div></body></html>